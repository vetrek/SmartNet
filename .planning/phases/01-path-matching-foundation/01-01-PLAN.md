---
phase: 01-path-matching-foundation
plan: 01
type: execute
---

<objective>
Create the PathMatcher protocol and integrate it into the middleware system while maintaining full backward compatibility with existing string-based path matching.

Purpose: Establish the foundation that enables exact, wildcard, glob, and regex matching in future phases.
Output: PathMatcher protocol, ContainsPathMatcher implementation, updated MiddlewareProtocol with matcher support, comprehensive tests.
</objective>

<execution_context>
~/.claude/get-shit-done/workflows/execute-phase.md
~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md

**Codebase context:**
@.planning/codebase/ARCHITECTURE.md
@.planning/codebase/CONVENTIONS.md
@.planning/codebase/TESTING.md

**Key files:**
@Source/Core/ApiClient+Middleware.swift
@Source/Core/ApiClient+Closure.swift (lines 203-218 - middlewareGroups function)
@Tests/IntegrationTests/ApiClientMiddlewareTests.swift

**Current behavior to preserve:**
- `pathComponent: "/"` matches all requests (global middleware)
- `pathComponent: "users"` matches paths containing "users" segment
- Matching uses `url.pathComponents.contains(pathComponent)`

**Constraints:**
- Zero dependencies (Foundation only)
- Thread-safe (matchers must be Sendable)
- Backward compatible (existing code must work unchanged)
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create PathMatcher protocol and ContainsPathMatcher</name>
  <files>Source/Core/PathMatcher.swift</files>
  <action>
Create a new file `Source/Core/PathMatcher.swift` with:

1. `PathMatcher` protocol:
   - `func matches(path: String) -> Bool` - check if pattern matches the given URL path
   - `var pattern: String { get }` - the pattern string for debugging/logging
   - Conform to `Sendable` for thread safety

2. `ContainsPathMatcher` struct implementing PathMatcher:
   - Stores a path component string
   - `matches(path:)` returns true if:
     - pattern is "/" (global matcher)
     - OR path components contain the pattern
   - Use `path.split(separator: "/")` for component extraction (matches URL.pathComponents behavior)

3. Factory method `PathMatcher.contains(_ component: String) -> PathMatcher`:
   - Returns ContainsPathMatcher for the component
   - Provides ergonomic API: `PathMatcher.contains("users")`

Follow existing conventions:
- MIT license header
- Public API with explicit access modifiers
- DocStrings for public types and methods
  </action>
  <verify>swift build compiles without errors</verify>
  <done>PathMatcher.swift exists with protocol and ContainsPathMatcher, swift build passes</done>
</task>

<task type="auto">
  <name>Task 2: Integrate PathMatcher into MiddlewareProtocol</name>
  <files>Source/Core/ApiClient+Middleware.swift, Source/Core/ApiClient+Closure.swift</files>
  <action>
Update middleware infrastructure to use PathMatcher:

1. In `ApiClient+Middleware.swift`:
   - Add `var pathMatcher: PathMatcher { get }` to MiddlewareProtocol
   - Add default implementation returning `ContainsPathMatcher(pattern: pathComponent)` for backward compatibility
   - Update Middleware struct to store a PathMatcher
   - Add new initializer: `init(pathMatcher: PathMatcher, preRequestCallback:, postResponseCallback:)`
   - Keep existing `init(pathComponent:...)` for backward compatibility (internally creates ContainsPathMatcher)
   - Deprecate pathComponent property with `@available(*, deprecated, message: "Use pathMatcher.pattern instead")`

2. In `ApiClient+Closure.swift` function `middlewareGroups(for:)`:
   - Change line 210-214 matching logic to use `$0.pathMatcher.matches(path: url.path)`
   - Remove the special "/" check - ContainsPathMatcher handles it
   - Simplify: all middlewares go through same matching logic

Key: Existing code using `pathComponent: "/"` and `pathComponent: "users"` must work unchanged.
  </action>
  <verify>swift build compiles, swift test runs existing middleware tests</verify>
  <done>MiddlewareProtocol has pathMatcher, middlewareGroups uses PathMatcher.matches(), existing tests pass</done>
</task>

<task type="auto">
  <name>Task 3: Add PathMatcher unit tests</name>
  <files>Tests/UnitTests/PathMatcherTests.swift</files>
  <action>
Create comprehensive unit tests for PathMatcher:

```swift
@Suite("PathMatcher Tests")
struct PathMatcherTests {
  // ContainsPathMatcher tests
  @Test("Global matcher matches any path")
  // pattern "/" matches "/users", "/api/v1/data", "/"

  @Test("Component matcher matches path containing component")
  // pattern "users" matches "/users", "/api/users/123", "/v1/users"

  @Test("Component matcher does not match unrelated paths")
  // pattern "users" does NOT match "/posts", "/api/v1/data"

  @Test("Component matcher is case sensitive")
  // pattern "Users" does NOT match "/users"

  @Test("Empty path handling")
  // pattern "users" does NOT match ""

  @Test("Factory method creates correct matcher")
  // PathMatcher.contains("users") returns ContainsPathMatcher
}
```

Follow existing test patterns from TESTING.md:
- Use Swift Testing framework (@Suite, @Test, #expect)
- Clear test names describing behavior
- Arrange-Act-Assert structure
  </action>
  <verify>swift test --filter PathMatcherTests runs all tests and passes</verify>
  <done>PathMatcherTests.swift exists with 6+ tests, all tests pass</done>
</task>

</tasks>

<verification>
Before declaring phase complete:
- [ ] `swift build` succeeds without errors or warnings
- [ ] `swift test` passes all tests (existing + new PathMatcher tests)
- [ ] Existing middleware tests in ApiClientMiddlewareTests.swift still pass
- [ ] `swiftlint` reports no new violations
</verification>

<success_criteria>

- PathMatcher protocol exists with matches(path:) and pattern
- ContainsPathMatcher implements PathMatcher with current behavior
- MiddlewareProtocol has pathMatcher property with backward-compatible default
- middlewareGroups() uses PathMatcher for all matching decisions
- All existing tests pass (backward compatibility verified)
- New unit tests cover PathMatcher behavior
</success_criteria>

<output>
After completion, create `.planning/phases/01-path-matching-foundation/01-01-SUMMARY.md` following the summary template.
</output>
