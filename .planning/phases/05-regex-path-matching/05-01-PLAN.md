---
phase: 05-regex-path-matching
plan: 01
type: execute
---

<objective>
Implement RegexPathMatcher for full regex pattern support using Foundation's NSRegularExpression.

Purpose: Complete the path matching system with the most powerful and flexible matching option for complex routing patterns.
Output: Working RegexPathMatcher with factory method and comprehensive tests.
</objective>

<execution_context>
~/.claude/get-shit-done/workflows/execute-phase.md
./summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md

# Prior phase summaries (dependency chain):
@.planning/phases/04-glob-pattern-matching/04-01-SUMMARY.md

# Key files:
@Source/Core/PathMatcher.swift
@Tests/UnitTests/PathMatcherTests.swift

**Tech stack available:** Foundation NSRegularExpression
**Established patterns:**
- PathMatcher protocol with `pattern` property and `matches(path:)` method
- Sendable conformance for thread safety
- Factory method pattern: `PathMatcher.regex(_:)` on constrained extension
- Segment normalization not needed (regex operates on full path string)
- Test pattern: Swift Testing framework with @Suite, @Test, #expect

**Constraining decisions:**
- Phase 01: PathMatcher protocol structure established
- Phase 04: GlobPathMatcher shows complex matching can be done simply
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create RegexPathMatcher implementation</name>
  <files>Source/Core/PathMatcher.swift</files>
  <action>
Add RegexPathMatcher struct after GlobPathMatcher in PathMatcher.swift:

1. RegexPathMatcher struct conforming to PathMatcher:
   - `pattern` property storing the regex pattern string
   - Private `regex` property of type NSRegularExpression (compiled once at init)
   - Failable init `init?(pattern: String)` that compiles regex, returns nil on invalid pattern
   - Alternative throwing init `init(pattern: String) throws` for when you want error details
   - `matches(path:)` implementation using `firstMatch(in:options:range:)` on the full path
   - Match should check if the pattern matches the ENTIRE path (anchor to start/end) OR let user control anchoring

Implementation notes:
- Store compiled NSRegularExpression to avoid recompiling on each match
- For `matches(path:)`: Check if regex has at least one match in the path string
- The regex pattern should match against the path as-is (no normalization - regex users control their patterns)
- Consider: Should "/" global pattern work? Decision: Let regex handle it naturally - user writes ".*" or "^/$" as they need

2. Factory method in extension:
   ```swift
   public extension PathMatcher where Self == RegexPathMatcher {
     static func regex(_ pattern: String) -> RegexPathMatcher {
       // Use force-try since factory should only be called with valid patterns
       // Or return optional - decision: return optional for safety
     }
   }
   ```

Avoid: Don't add path normalization - regex users expect full control over their patterns. Don't catch and swallow regex compilation errors silently in the failable init - that's the point of the failable init.
  </action>
  <verify>swift build compiles without errors</verify>
  <done>RegexPathMatcher struct exists, compiles NSRegularExpression at init, matches using firstMatch</done>
</task>

<task type="auto">
  <name>Task 2: Add RegexPathMatcher unit tests</name>
  <files>Tests/UnitTests/PathMatcherTests.swift</files>
  <action>
Add test section after GlobPathMatcher tests:

```swift
// MARK: - RegexPathMatcher Tests
```

Test cases to add:
1. Basic regex matching - pattern "^/users/\\d+$" matches "/users/123" but not "/users/abc"
2. Regex special characters work - test character classes, quantifiers, alternation
3. Case insensitive option - test with NSRegularExpression.Options.caseInsensitive if supported
4. Invalid regex pattern returns nil from failable init
5. Throwing init throws on invalid pattern
6. Empty pattern behavior (matches empty string? matches anything?)
7. Pattern without anchors matches substring - "/users" pattern matches "/users" and "/users/123"
8. Anchored pattern for exact match - "^/users$" matches only "/users"
9. Complex pattern - test something like "^/api/v[12]/users/[a-z]+$"
10. Factory method creates correct matcher
11. Pattern property returns original pattern string
12. Regex with capture groups works (even if we don't expose captures)
13. Path with special regex chars is treated as literal in path (e.g., path "/users/test.html" matched by "test\\.html")

Follow established test patterns:
- Use @Test("Description") attribute
- Use #expect() for assertions
- Test names follow `functionNameDescribesWhatIsTested()` pattern
  </action>
  <verify>swift test --filter PathMatcherTests passes all tests</verify>
  <done>At least 10 RegexPathMatcher test cases pass covering basic regex, anchoring, invalid patterns, factory method</done>
</task>

</tasks>

<verification>
Before declaring phase complete:
- [ ] `swift build` succeeds without errors
- [ ] `swift test` passes all tests
- [ ] RegexPathMatcher handles valid and invalid regex patterns appropriately
- [ ] Factory method `PathMatcher.regex(_:)` works
</verification>

<success_criteria>
- All tasks completed
- All verification checks pass
- No errors or warnings introduced
- RegexPathMatcher provides full NSRegularExpression functionality
- Phase 5: Regex Path Matching complete (final phase of milestone)
</success_criteria>

<output>
After completion, create `.planning/phases/05-regex-path-matching/05-01-SUMMARY.md`
</output>
